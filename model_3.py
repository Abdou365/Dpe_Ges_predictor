# -*- coding: utf-8 -*-
"""One_Hot_Encoder_Prediction_DPE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aaF6LtJu7hPMLCotBmXhcrcIidHjSKqf

## Importer le fichier
"""

import pandas as pd

df = pd.read_csv('Original_DPE_Data.csv')
df



df.columns.to_list()

# réduire le nombre de colonne

columns_needed_reduced = [
        'Année_construction', 'Surface_habitable_logement', 'Code_postal_(BAN)',
    'Conso_5_usages_é_finale', 'Conso_5_usages/m²_é_finale',
    'Emission_GES_5_usages', 'Emission_GES_5_usages_par_m²',
    'Coût_total_5_usages', 'Coût_chauffage', 'Coût_ECS',
    'Type_énergie_principale_chauffage', 'Type_installation_chauffage',
    'Qualité_isolation_enveloppe', 'Qualité_isolation_menuiseries',
    'Etiquette_DPE', 'Etiquette_GES'
]


columns_to_keep = [col for col in columns_needed_reduced if col in df.columns]
df = df[columns_to_keep]
df



# convertir les chiffres en format string en float

convertToFloat =  ["Conso_5_usages_é_finale",
                   "Conso_5_usages/m²_é_finale",
                   "Emission_GES_5_usages",
                   "Emission_GES_5_usages_par_m²",
                   "Surface_habitable_logement",
                   "Coût_total_5_usages",
                   "Coût_chauffage",
                   "Coût_ECS"]

for col in convertToFloat:
  df[col] = pd.to_numeric(df[col], errors='coerce')



from sklearn.impute import SimpleImputer

# Imputateur pour les variables numériques
imputer_num = SimpleImputer(strategy='median')
numerical_cols = df.select_dtypes(include=['int64', 'float64']).columns
df[numerical_cols] = imputer_num.fit_transform(df[numerical_cols])

# Imputateur pour les variables catégorielles
imputer_cat = SimpleImputer(strategy='most_frequent')
categorical_cols = df.select_dtypes(include=['object']).columns
df[categorical_cols] = imputer_cat.fit_transform(df[categorical_cols])

# df = df.dropna()

len(df.columns.to_list())

# Avoir en stock toute les valeur présent dans le tableau

allValueByColumns = {}

for col in columns_to_keep:
  allValueByColumns[col] = pd.unique(df[col])

allValueByColumns

categorical_cols

from sklearn.preprocessing import LabelEncoder

# Initialiser un objet LabelEncoder
encoder = {}

# Appliquer l'encodage par labels à chaque colonne catégorielle
for col in categorical_cols:
  encoder[col] = LabelEncoder()
  df[col] = encoder[col].fit_transform(df[col])

encoder

X = df.drop(["Etiquette_DPE",	"Etiquette_GES"], axis=1)
X

y = df[["Etiquette_DPE",	"Etiquette_GES"]]
y

# Séparation du jeu de données en jeu d'entrainement et en jeu de test
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

from sklearn.ensemble import RandomForestClassifier

model = RandomForestClassifier(n_estimators=100,random_state=42)

model.fit(X_train, y_train)

y_pred = model.predict(X_test)

from sklearn.metrics import classification_report, accuracy_score

classification_report(y_test['Etiquette_DPE'], y_pred[:, 0])  # Première colonne de y_pred



classification_report(y_test['Etiquette_GES'], y_pred[:, 1])  # Deuxième colonne de y_pred

import random

def random_value():
  randomV = {}
  for col in columns_needed_reduced:
    randomV[col]= allValueByColumns[col][random.randint(0, len(allValueByColumns[col])-1)]
  return randomV





def predict_dpe_ges(
    Annee_construction=None,
    Cout_total_5_usages=None,
    Surface_habitable_logement=None,
    Qualite_isolation_enveloppe=None,
    Type_energie_principale_chauffage=None,
    Type_installation_chauffage=None,
    Code_postal_BAN=None,
    Conso_5_usages_e_finale=None,
    Conso_5_usagesm2_e_finale=None,
    Emission_GES_5_usages=None,
    Emission_GES_5_usages_par_m2=None,
    Cout_chauffage=None,
    Cout_ECS=None,
    Qualite_isolation_menuiseries=None
    ):

    random_values = random_value()
    Annee_construction = Annee_construction if Annee_construction is not None else random_values['Année_construction']
    Cout_total_5_usages = Cout_total_5_usages if Cout_total_5_usages is not None else allValueByColumns['Coût_total_5_usages'].mean()
    Surface_habitable_logement = Surface_habitable_logement if Surface_habitable_logement is not None else allValueByColumns['Surface_habitable_logement'].mean()
    Qualite_isolation_enveloppe = Qualite_isolation_enveloppe if Qualite_isolation_enveloppe is not None else random_values["Qualité_isolation_enveloppe"]
    Type_energie_principale_chauffage = Type_energie_principale_chauffage if Type_energie_principale_chauffage is not None else random_values['Type_énergie_principale_chauffage']
    Type_installation_chauffage = Type_installation_chauffage if Type_installation_chauffage is not None else random_values['Type_installation_chauffage']
    Code_postal_BAN = Code_postal_BAN if Code_postal_BAN is not None else random_values['Code_postal_(BAN)']
    Conso_5_usages_e_finale = Conso_5_usages_e_finale if Conso_5_usages_e_finale is not None else allValueByColumns['Conso_5_usages_é_finale'].mean()
    Conso_5_usagesm2_e_finale = Conso_5_usagesm2_e_finale if Conso_5_usagesm2_e_finale is not None else allValueByColumns['Conso_5_usages/m²_é_finale'].mean()
    Emission_GES_5_usages = Emission_GES_5_usages if Emission_GES_5_usages is not None else allValueByColumns['Emission_GES_5_usages'].mean()
    Emission_GES_5_usages_par_m2 = Emission_GES_5_usages_par_m2 if Emission_GES_5_usages_par_m2 is not None else allValueByColumns['Emission_GES_5_usages_par_m²'].mean()
    Cout_chauffage = Cout_chauffage if Cout_chauffage is not None else allValueByColumns['Coût_chauffage'].mean()
    Cout_ECS = Cout_ECS if Cout_ECS is not None else allValueByColumns['Coût_ECS'].mean()
    Qualite_isolation_menuiseries = Qualite_isolation_menuiseries if Qualite_isolation_menuiseries is not None else encoder['Qualité_isolation_menuiseries'].transform([random_values['Qualité_isolation_menuiseries']])[0]

 # Function to transform categorical values and handle unseen labels
    def transform_with_encoder(column, value):
        try:
            return encoder[column].transform([value])[0]
        except ValueError:
            # Handle unseen labels by assigning the most frequent class or another strategy
            return encoder[column].transform([encoder[column].classes_[0]])[0]

    # Transform the categorical features
    Type_energie_principale_chauffage = transform_with_encoder('Type_énergie_principale_chauffage', Type_energie_principale_chauffage)
    Type_installation_chauffage = transform_with_encoder('Type_installation_chauffage', Type_installation_chauffage)
    Qualite_isolation_enveloppe = transform_with_encoder('Qualité_isolation_enveloppe', Qualite_isolation_enveloppe)
    Qualite_isolation_menuiseries = transform_with_encoder('Qualité_isolation_menuiseries', Qualite_isolation_menuiseries)

    # Définir les valeurs par défaut pour les autres caractéristiques (si nécessaire)
    features = [
        'Année_construction',
        'Surface_habitable_logement',
        'Code_postal_(BAN)',
        'Conso_5_usages_é_finale',
        'Conso_5_usages/m²_é_finale',
        'Emission_GES_5_usages',
        'Emission_GES_5_usages_par_m²',
        'Coût_total_5_usages',
        'Coût_chauffage',
        'Coût_ECS',
        'Type_énergie_principale_chauffage',
        'Type_installation_chauffage',
        'Qualité_isolation_enveloppe',
        'Qualité_isolation_menuiseries'
    ]



    # print(random_values)

    default_values = [
        Annee_construction,
        Surface_habitable_logement,
        Code_postal_BAN,
        Conso_5_usages_e_finale,
        Conso_5_usagesm2_e_finale,
        Emission_GES_5_usages,
        Emission_GES_5_usages_par_m2,
        Cout_total_5_usages,
        Cout_chauffage,
        Cout_ECS,
        Type_energie_principale_chauffage,
        Type_installation_chauffage,
        Qualite_isolation_enveloppe,
        Qualite_isolation_menuiseries
    ]



    # Créer le DataFrame pour la prédiction
    df = pd.DataFrame([default_values], columns=features)

    # Prédire en utilisant le modèle pré-entraîné
    predictions = model.predict(df)
    dpe = predictions[0]
    

    return {
        "Etiquette_DPE": int(dpe[0]),  # Ensure it's an int
        "Etiquette_GES": int(dpe[1])   # Ensure it's an int
    }

# Exemple d'appel de fonction avec tous les paramètres nécessaires
test = predict_dpe_ges(
    Annee_construction=1945,
    Cout_total_5_usages=575,
    Surface_habitable_logement=57,
    Qualite_isolation_enveloppe="insuffisante",
    Type_energie_principale_chauffage="Électricité",
    Type_installation_chauffage="mixte (collectif-individuel)",
    Code_postal_BAN=73600,
    Conso_5_usages_e_finale=5900,
    Conso_5_usagesm2_e_finale=103,
    Emission_GES_5_usages=438,
    Emission_GES_5_usages_par_m2=7.6,
    Cout_chauffage=650,
    Cout_ECS=331.6,
    Qualite_isolation_menuiseries="bonne"
)
print(test)

# Exemple d'appel de fonction avec tous les paramètres nécessaires
test = predict_dpe_ges(
    Annee_construction=1996,
    Cout_total_5_usages=1243,
    Surface_habitable_logement=226,
    Qualite_isolation_enveloppe="bonne",
    Type_energie_principale_chauffage="Gaz naturel",
    Type_installation_chauffage="mixte (collectif-individuel)",
    Code_postal_BAN=21121,
    Conso_5_usages_e_finale=19352.6,
    Conso_5_usagesm2_e_finale=85.6,
    Emission_GES_5_usages=3616,
    Emission_GES_5_usages_par_m2=16,
    Cout_chauffage=0,
    Cout_ECS=0,
    Qualite_isolation_menuiseries="très bonne"
)
print(test)